{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ar-anchors.js","webpack:///./src/ar-camera.js","webpack:///./src/ar-images.js","webpack:///./src/ar-planes.js","webpack:///./src/ar-raycaster.js","webpack:///./src/ar.js","webpack:///./src/index.js","webpack:///./src/mozilla-xr-ar.js","webpack:///./src/webxr-ar.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACpBD;;AAEA;AACA;AACA,cAAc;AACd,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,6BAA6B,QAAQ;;AAErC;AACA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;AACA,cAAc,uCAAuC;;AAErD;AACA;AACA;AACA,cAAc,uCAAuC;;AAErD;AACA;AACA;AACA,mBAAmB,4DAA4D;AAC/E,K;AACA,GAAG;;AAEH;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,G;AACA,CAAC;;;;;;;;;;;;AC9DD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC;;;;;;;;;;;;AC3BD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,2BAA2B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,qBAAqB;AACrB,sCAAsC,iCAAiC;;AAEvE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D,4BAA4B,oCAAoC,E;AAChE,kCAAkC,qCAAqC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;ACnND;;AAEA;AACA;AACA,0C;AACA;;AAEA;AACA,QAAQ,aAAa;AACrB,QAAQ,aAAa;AACrB,SAAS;AACT,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,oBAAoB,+DAA+D;AACnF,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,G;AACA,CAAC;;;;;;;;;;;;;ACnED;;AAEA;AACA;AACA,qBAAqB,cAAc;AACnC,uBAAuB,eAAe;AACtC,mBAAmB,cAAc;AACjC,aAAa;AACb,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,E;AACP;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kDAAkD,eAAe;AACjE;;AAEA;AACA;AACA,yBAAyB,0CAA0C;AACnE;AACA,CAAC;;;;;;;;;;;;ACvDD,mBAAO,CAAC,qCAAY;AACpB;AACA,mBAAO,CAAC,+CAAiB;AACzB,mBAAO,CAAC,uCAAa;AACrB,mBAAO,CAAC,yCAAc;AACtB,mBAAO,CAAC,uCAAa;AACrB,mBAAO,CAAC,yBAAM;AACd,mBAAO,CAAC,uCAAa;AACrB,mBAAO,CAAC,6CAAgB;;;;;;;;;;;;;ACRxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA,yBAAyB,cAAc;AACvC,2BAA2B,eAAe;AAC1C,uBAAuB;AACvB,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,+DAA+D,QAAQ;AACvE,oDAAoD,QAAQ;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC,mCAAmC,EAAE;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB,EAAE;AAC1D,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA,+DAA+D,QAAQ;AACvE,qDAAqD,QAAQ;;AAE7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;;AAEA,kEAAkE;AAClE;AACA;;AAEA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8BAA8B,aAAa;AAC3C;AACA,KAAK;;AAEL;AACA,8BAA8B,aAAa;AAC3C;AACA,KAAK;;AAEL;AACA,8BAA8B,aAAa;AAC3C;AACA,KAAK;;AAEL;AACA,8BAA8B,aAAa;AAC3C;AACA,KAAK;;AAEL;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;AACA;AACA,S;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA,gDAAgD;AAChD,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,mCAAmC;;AAEnC;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B,sBAAsB,MAAM;AAC5B,sBAAsB,MAAM;AAC5B,sBAAsB,MAAM;AAC5B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,WAAW;;AAE7C;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,S;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;AC11BD;;AAEA;AACA;AACA,yBAAyB,cAAc;AACvC,2BAA2B,eAAe;AAC1C,uBAAuB,eAAe;AACtC,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,oBAAoB;AAC7D,yCAAyC,oBAAoB;AAC7D,yCAAyC,oBAAoB;AAC7D,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;AACA,4CAA4C;AAC5C,0CAA0C;AAC1C;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D,SAAS;;AAET;AACA;AACA,KAAK;;AAEL;AACA;AACA,gEAAgE,QAAQ;;AAExE;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iGAAiG,0BAA0B;AAC3H,iBAAiB;AACjB;AACA;AACA,iGAAiG,0BAA0B;AAC3H,iBAAiB;AACjB;AACA;AACA,6HAA6H,0BAA0B;AACvJ,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,gDAAgD,6BAA6B;AAC7E;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,gDAAgD,6BAA6B;AAC7E;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,6D;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,sDAAsD,uBAAuB,gBAAgB;AAC7F;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;;AAEL;AACA,8DAA8D,aAAa;AAC3E;AACA,KAAK;;AAEL;AACA,8DAA8D,aAAa;AAC3E;AACA,KAAK;;AAEL;AACA,8DAA8D,aAAa;AAC3E;AACA,KAAK;;AAEL;AACA,8DAA8D,aAAa;AAC3E;AACA,KAAK;;AAEL,yB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,WAAW;AAC7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,8BAA8B,aAAa;;AAE3C;AACA,KAAK;;AAEL;AACA,8BAA8B,aAAa;;AAE3C;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,CAAC","file":"aframe-ar.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* global AFRAME, THREE */\n\nAFRAME.registerComponent('ar-anchors', {\n\n  getSource: function () {\n    var whichar;\n    if (!this.source) {\n      whichar = this.el.sceneEl.components['ar'];\n      if (whichar) {\n        this.source = whichar.getSource();\n      }\n    }\n    return this.source;\n  },\n\n  getAnchors: function () {\n    var source = this.getSource();\n    if (!source || !source.getAnchors) return undefined;\n    return source.getAnchors();\n  }\n});\n","/* global AFRAME */\n\nAFRAME.registerComponent('ar-camera', {\n  schema: {\n    enabled: {default:true}\n  },\n\n  init: function () {\n    var lookControls = this.el.getAttribute('look-controls');\n    this.wasLookControlsEnabled = lookControls ? lookControls.enabled : false;\n  },\n\n  update: function (oldData) {\n    if (!oldData || oldData.enabled !== this.data.enabled) {\n      // Value changed, so react accordingly.\n      if (this.data.enabled) {\n        // Save camera look-controls enabled, and turn off for AR.\n        var lookControls = this.el.getAttribute('look-controls');\n        this.wasLookControlsEnabled = lookControls ? lookControls.enabled : false;\n        if (this.wasLookControlsEnabled) {\n          this.el.setAttribute('look-controls', 'enabled', false);\n        }\n      } else {\n        // Restore camera look-controls enabled.\n        if (this.wasLookControlsEnabled) {\n          this.el.setAttribute('look-controls', 'enabled', true);\n        }\n      }\n    }\n  },\n  \n  tick: function (t, dt) {\n    if (!this.data.enabled) { return; }\n    \n    var whichar = this.checkWhichAR();\n    if (!whichar) { return; }\n    \n    // Apply the pose position via setAttribute,\n    // so that other A-Frame components can see the values.\n    var pos = whichar.getPosition();\n    if (pos) { this.el.setAttribute('position', pos); }\n\n    // Apply the pose rotation via setAttribute,\n    // so that other A-Frame components can see the values.\n    var rot = whichar.getRotation();\n    if (rot) { this.el.setAttribute('rotation', rot); }\n\n    // Apply the projection matrix, if we're not in VR.\n    if (!this.el.sceneEl.is('vr-mode')) {\n      var matrix = whichar.getProjectionMatrix();\n      if (matrix) { this.el.components.camera.camera.projectionMatrix = matrix; }\n    }    \n  },\n  \n  checkWhichAR: function () {\n    if (!this.whichar) {\n      var whichar = this.el.sceneEl.components['ar'].getSource();\n      if (!whichar || !whichar.arDisplay) { return; }\n      this.whichar = whichar;\n    }\n    return this.whichar;\n  }  \n});\n","/* global AFRAME, THREE */\n\nAFRAME.registerComponent('ar-images', {\n\n  getSource: function () {\n    var whichar;\n    if (!this.source) {\n      whichar = this.el.sceneEl.components['ar'];\n      if (whichar) {\n        this.source = whichar.getSource();\n      }\n    }\n    return this.source;\n  },\n\n  addImage: function (name, url, physicalWidth) {\n    var source = this.getSource();\n    if (!source || !source.addImage) return undefined;\n    return source.addImage(name, url, physicalWidth);\n  },\n\n  removeImage: function (name) {\n    var source = this.getSource();\n    if (!source || !source.removeImage) return undefined;\n    return source.removeImage(name);\n  },\n\n});\n","/* global AFRAME, THREE */\n\nAFRAME.registerComponent('ar-planes', {\n\n  getPlaneSource: function () {\n    var whichar;\n    if (!this.planeSource) {\n      whichar = this.el.sceneEl.components['ar'];\n      if (whichar) {\n        this.planeSource = whichar.getSource();\n      }\n    }\n    return this.planeSource;\n  },\n\n  getPlanes: function () {\n    var planeSource = this.getPlaneSource();\n    if (!planeSource || !planeSource.getPlanes) return undefined;\n    return planeSource.getPlanes();\n  },\n\n  init: function () {\n    // Remember planes when we see them.\n    this.planes = {};\n    this.anchorsAdded = [];\n    this.anchorsAddedDetail = {type:'added', anchors: this.anchorsAdded};\n    this.anchorsUpdated = [];\n    this.anchorsUpdatedDetail = {type:'updated', anchors: this.anchorsUpdated};\n    this.anchorsRemoved = [];\n    this.anchorsRemovedDetail = {type:'removed', anchors: this.anchorsRemoved};\n  },\n\n  tick: (function (t, dt) {\n    // Create the temporary variables we will reuse, if needed.\n    var tempScale = new THREE.Vector3(1, 1, 1);\n    var tempMat4 = new THREE.Matrix4();\n    var tempPosition = new THREE.Vector3();\n    var tempQuaternion = new THREE.Quaternion();\n\n    // The actual function, which we return.\n    return function (t, dt) {\n      // Get the list of planes.\n      var planes = this.getPlanes();\n      if (!planes) { return; }\n\n      // Ideally we would have either events, or separate lists for added / updated / removed.\n      var addedThese = [];\n      var updatedThese = [];\n      var removedThese = [];\n\n      // Because we don't have an indication of added / updated / removed,\n      // try to keep track ourselves.\n      var seenThese = {};\n      var i;\n\n      // Iterate over the available planes.\n      for (i=0; planes && i<planes.length; i++) {\n        var plane = planes[i];\n\n        // Force plane conformance to latest spec.\n        // (Hopefully soon, this will no longer be required.)\n        var planespec;\n        // Get plane identifier and conform.\n        var id = (plane.identifier !== undefined ? plane.identifier : plane.id).toString();\n        // Get plane timestamp, if available.\n        var timestamp = plane.timestamp;\n\n        // Note that we've seen it.\n        seenThese[id] = true;\n\n        var adding = !this.planes[id];\n        var hasTimestamp = timestamp !== undefined;\n        if (!adding) {\n            // We've seen this plane before.\n            // If this plane has a timestamp,\n            if (hasTimestamp) {\n                // And the timestamp is identical,\n                if (timestamp === this.planes[id].timestamp) {\n                    // Then we don't need to do any more work for this plane,\n                    // since it hasn't changed.\n                    continue;\n                } else {\n                    // We have a timestamp, and it doesn't match,\n                    // so we'll be updating the previous plane spec.\n                }\n            } else {\n                // This plane didn't have a timestamp,\n                // so unfortunately we'll need to do brute force comparison.\n                // We might update the previous plane spec afterward.\n            }\n        } else {\n            // We haven't seen this plane before, so we'll be adding it.\n        }\n\n        // If we're still here, we need to finish building the plane spec.\n\n        planespec = {identifier: id};\n        if (timestamp !== undefined) { planespec.timestamp = timestamp; }\n\n\t// New API plane spec uses modelMatrix (same as transform).\n        if (plane.modelMatrix || plane.transform) {\n          planespec.modelMatrix = plane.modelMatrix || plane.transform;\n        } else {\n          // Create modelMatrix from position and orientation.\n          tempPosition.fromArray(plane.position);\n          tempQuaternion.fromArray(plane.orientation);\n          tempScale.set(1, 1, 1);\n          tempMat4.compose(tempPosition, tempQuaternion, tempScale);\n          planespec.modelMatrix = tempMat4.elements.slice();\n        }\n\n        planespec.extent = plane.extent;\n        if (plane.center) { planespec.center = plane.center; }\n        if (plane.polygon) { planespec.vertices = plane.polygon; } \n        else if (plane.vertices) { planespec.vertices = plane.vertices; }\n\n        // Figure out whether added or updated.\n        // If we've seen it before,\n        if (!adding) {\n          // And it has a timestamp,\n          if (hasTimestamp) {\n            // We're updating it (because if not we'd be done already.)\n            updatedThese.push(planespec);\n\t  } else\n          // If it didn't have a timestamp, do brute force comparison.\n          // FIXME: better brute-force comparison!\n          if (AFRAME.utils.deepEqual(planespec, this.planes[id])) {\n            // It didn't change, so we're done with this one.\n            continue;\n          } else {\n            // It changed, so we're updating it.\n            // However, since we need to do brute force comparison,\n            // we'll need to clone it when we remember.\n            updatedThese.push(planespec);\n          }\n        } else {\n          // We haven't see it, so we're adding it.\n          addedThese.push(planespec)\n        }\n\n        // If we're still here, we need to remember the new planespec.\n\n        // If we have timestamps,\n        if (hasTimestamp) {\n          // We only need to compare that,\n          // so we don't need to copy or clone anything.\n          // since we always make a new plane spec right now.\n          this.planes[id] = planespec;\n        } else {\n          // Because the objects in the plane may be updated in place,\n          // we need to clone those parts of the remembered plane spec.\n          this.planes[id] = {\n            identifier: planespec.identifier,\n            modelMatrix: planespec.modelMatrix.slice(),\n            extent: planespec.extent.slice()\n          };\n/* WebXR Viewer problem? WebARon___ doesn't use.\n          if (planespec.center) {\n            this.planes[id].center = planespec.center.slice();\n          }\n*/\n          if (planespec.vertices) {\n            this.planes[id].vertices = planespec.vertices.slice();\n          }\n        }\n      }\n\n      // To find ones we've removed, we need to scan this.planes.\n      var self = this;\n      Object.keys(self.planes).forEach(function (key) {\n        if (!seenThese[key]) {\n          removedThese.push(self.planes[key]);\n          delete self.planes[key];\n        }\n      });\n\n      // OK, now we should have separate added / updated / removed lists,\n      // with planes that match spec,\n      // from which we can emit appropriate events downstream.\n\n      // Replace the old list.\n      this.anchorsAdded = addedThese;\n      // Emit event if list isn't empty.\n      if (addedThese.length > 0) {\n        // Reuse the same event detail to avoid making garbage.\n        // TODO: Reuse same CustomEvent?\n        this.anchorsAddedDetail.anchors = addedThese;\n        this.el.emit('anchorsadded', this.anchorsAddedDetail);\n      }\n\n      // Replace the old list.\n      this.anchorsUpdated = updatedThese;\n      // Emit event if list isn't empty.\n      if (updatedThese.length > 0) {\n        // Reuse the same event detail to avoid making garbage.\n        // TODO: Reuse same CustomEvent?\n        this.anchorsUpdatedDetail.anchors = updatedThese;\n        this.el.emit('anchorsupdated', this.anchorsUpdatedDetail);\n      }\n\n      // Replace the old list.\n      this.anchorsRemoved = removedThese;\n      // Emit event if list isn't empty.\n      if (removedThese.length > 0) {\n        // Reuse the same event detail to avoid making garbage.\n        // TODO: Reuse same CustomEvent?\n        this.anchorsRemovedDetail.anchors = removedThese;\n        this.el.emit('anchorsremoved', this.anchorsRemovedDetail);\n      }\n    };    \n  })()\n});\n","/* global AFRAME */\n\n// ar-raycaster modifies raycaster to append AR hit, if any.\n// But note that current AR hit API does not support orientation as input.\nAFRAME.registerComponent('ar-raycaster', {      \n  dependencies: ['raycaster'],\n        \n  schema: {\n    x: {default: 0.5},\n    y: {default: 0.5},\n    el: {type: 'selector'}\n  },\n        \n  init: function () {\n    // HACK: monkey-patch raycaster to append AR hit result\n    this.raycaster = this.el.components['raycaster'].raycaster;\n    this.raycasterIntersectObjects = this.raycaster.intersectObjects.bind(this.raycaster);\n    this.raycaster.intersectObjects = this.intersectObjects.bind(this);\n  },\n        \n  update: function (oldData) {\n    if (!this.data.el) {\n      // If not given some other element, return hit against the scene.\n      // HACK: But that means we need its object3D to have an el.\n      if (!this.el.sceneEl.object3D.el) {\n        this.el.sceneEl.object3D.el = this.el.sceneEl;\n      }\n    }\n  },\n        \n  intersectObjects: function (objects, recursive, rawIntersections) {\n    // it appears that intersectObjects is now returning in rawIntersections\n    var results = this.raycasterIntersectObjects(objects, recursive, rawIntersections);\n    // Tack on AR hit result, if any.\n    var hitARResults = this.hitAR();\n    if (hitARResults && hitARResults.length) {\n      if (rawIntersections) {\n        hitARResults.forEach((hit) => rawIntersections.push(hit));\n        results = rawIntersections;\n      } else {\n        hitARResults.forEach((hit) => results.push(hit));\n      }\n    }\n    return results;\n  },        \n        \n  hitAR: function () {\n    var whichar = this.checkWhichAR();\n    if (!whichar || !whichar.arDisplay) { return []; }\n    var x = this.data.x;\n    var y = this.data.y;\n    if (arguments.length >= 2) {\n      x = arguments[0];\n      y = arguments[1];\n    }\n    return whichar.hitAR(x, y, this.data.el, this.el);\n  },\n\n  checkWhichAR: function () {\n    if (!this.whichar) {\n      var whichar = this.el.sceneEl.components['ar'];\n      if (whichar) { whichar = whichar.getSource ? whichar.getSource() : undefined; }\n      if (!whichar || !whichar.arDisplay) { return; }\n      this.whichar = whichar;\n    }\n    return this.whichar;\n  }  \n});\n\n","/* global AFRAME */\n\nAFRAME.registerComponent('ar', {\n  schema: {\n    takeOverCamera: {default: true},\n    cameraUserHeight: {default: false},\n    worldSensing: {default: true},\n    hideUI: {default: false}\n  },\n  dependencies: ['webxr-ar', 'mozilla-xr-ar', 'ar-planes', 'ar-anchors'],\n  getSource: function () {\n    var whichar;\n    if (!this.source) {\n      var self = this;\n      self.dependencies.forEach(function(sys) {\n        whichar = self.el.sceneEl.components[sys];\n        if (whichar && whichar.arDisplay) {\n          self.source = whichar;\n        }\n      });\t\n    }\n    return this.source;\n  },\n  getPlanes: function () {\n    return this.source ? this.source.getPlanes() : undefined;\n  },\n  getAnchors: function () {\n    return this.source ? this.source.getAnchors() : undefined;\n  },\n  addImage: function (name, url, physicalWidth) {\n    return this.source.addImage(name, url, physicalWidth);\n  },\n  removeImage: function (name) {\n    return this.source.removeImage(name);\n  },\n  init: function () {\n    var options = {\n      takeOverCamera: this.data.takeOverCamera,\n      cameraUserHeight: this.data.cameraUserHeight,\n      worldSensing: this.data.worldSensing\n    };\n\n    var self = this;\n    this.dependencies.forEach(function(sys) {\n        self.el.setAttribute(sys, options);\n    });\n\n    if (this.data.hideUI) {\n      this.el.sceneEl.setAttribute('vr-mode-ui', {enabled: false});\n    }\n\n    // Ensure passthrough is visible, make sure A-Frame styles don't interfere.\n    document.head.insertAdjacentHTML('beforeend', \n      '<style>html,body {background-color: transparent !important;}</style>');\n  }\n});\n","require('./webxr-ar');\n//require('./three-ar');\nrequire('./mozilla-xr-ar');\nrequire('./ar-planes');\nrequire('./ar-anchors');\nrequire('./ar-images');\nrequire('./ar');\nrequire('./ar-camera');\nrequire('./ar-raycaster');\n\n","/* global AFRAME, THREE */\n\nfunction convertVertices(vertices) {\n    var verticesLength = vertices.length;\n    var newVertices = new Float32Array(verticesLength * 3);\n    var i = 0;\n    var j = 0;\n    var vertex;\n    for (i = 0; i < verticesLength; i++) {\n        vertex = vertices[i];\n        newVertices[j] = vertex.x;\n        newVertices[j + 1] = vertex.y;\n        newVertices[j + 2] = vertex.z;\n        j += 3;\n    }\n    return newVertices;\n}\n\n\nfunction encode(buffer) {\nvar base64    = ''\nvar encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\nvar bytes      = buffer;  // assume it's a typedArrayBuffer \n        \nif (buffer instanceof ArrayBuffer) {\nbytes = new Uint8Array(arrayBuffer)\n} else if (buffer instanceof ImageData) {\nbytes = buffer.data\n}\n\nvar byteLength    = buffer.length\nvar byteRemainder = byteLength % 3\nvar mainLength    = byteLength - byteRemainder\n\nvar a, b, c, d\nvar chunk\n\n// Main loop deals with bytes in chunks of 3\nfor (var i = 0; i < mainLength; i = i + 3) {\n// Combine the three bytes into a single integer\nchunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]\n\n// Use bitmasks to extract 6-bit segments from the triplet\na = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18\nb = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12\nc = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6\nd = chunk & 63               // 63       = 2^6 - 1\n\n// Convert the raw binary segments to the appropriate ASCII encoding\nbase64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]\n}\n\n// Deal with the remaining bytes and padding\nif (byteRemainder == 1) {\nchunk = bytes[mainLength]\n\na = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2\n\n// Set the 4 least significant bits to zero\nb = (chunk & 3)   << 4 // 3   = 2^2 - 1\n\nbase64 += encodings[a] + encodings[b] + '=='\n} else if (byteRemainder == 2) {\nchunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]\n\na = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10\nb = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4\n\n// Set the 2 least significant bits to zero\nc = (chunk & 15)    <<  2 // 15    = 2^4 - 1\n\nbase64 += encodings[a] + encodings[b] + encodings[c] + '='\n}\n\nreturn base64\n}\n\n\n\n\n\nAFRAME.registerComponent('mozilla-xr-ar', {\n    schema: {\n        takeOverCamera: {default: true},\n        cameraUserHeight: {default: false},\n        worldSensing: {default: true}\n    },\n\n    init: function () {\n        this.onInit = this.onInit.bind(this);\n        this.onWatch = this.onWatch.bind(this);\n\n        this.poseMatrix = new THREE.Matrix4();\n        this.posePosition = new THREE.Vector3();\n        this.poseQuaternion = new THREE.Quaternion();\n        this.poseEuler = new THREE.Euler(0, 0, 0, 'YXZ');\n        this.poseRotation = new THREE.Vector3();\n        this.projectionMatrix = new THREE.Matrix4();\n        this.viewMatrix = new THREE.Matrix4();\n\n        this.onceSceneLoaded = this.onceSceneLoaded.bind(this);\n        if (this.el.sceneEl.hasLoaded) {\n            setTimeout(this.onceSceneLoaded);\n        } else {\n            this.el.sceneEl.addEventListener('loaded', this.onceSceneLoaded);\n        }\n\n        // Add planes handling, so we can do synchronous hit test.\n        // From google-ar/WebARonARKit; also see webxr-polyfill/ARKitWrapper.js\n\n        this.planes_ = new Map();\n        this.anchors_ = new Map();\n    },\n\n    // For WebXR Viewer, we are currently directly hooking the callback\n    // used to provide frame data, so we don't need to do anything in tick!\n\n    takeOverCamera: function (camera) {\n        this.arCamera = camera;\n        camera.el.setAttribute('ar-camera', 'enabled', true);\n    },\n\n    onceSceneLoaded: function () {\n        // Check if the low-level WebXR Viewer interfaces are there.\n        if (!window.webkit || !window.webkit.messageHandlers) { return; }\n        if (!window.webkit.messageHandlers.initAR) { return; }\n\n        window['arkitCallback' + 0] = this.onInit;\n        window['arkitCallback' + 1] = this.onWatch;\n\n        // Compose data to use with initAR.\n        var data = {\n            options: {\n                ui: {\n                    browser: true,\n                    points: true,\n                    focus: false,\n                    rec: true,\n                    rec_time: true,\n                    mic: false,\n                    build: false,\n                    plane: true,\n                    warnings: true,\n                    anchors: false,\n                    debug: true,\n                    statistics: false\n                }\n            },\n            callback: 'arkitCallback0' // this.onInit as window callback\n        };\n\n        // Need these because WebXR Viewer...\n        //if (window['setNativeTime']) {\n        //  console.log('window handler already defined for ', 'setNativeTime');\n        //} else\n        window['setNativeTime'] = function (data) {\n          window.nativeTime = data.nativeTime;\n        };\n        [\n         'arkitStartRecording',\n         'arkitStopRecording',\n         'arkitDidMoveBackground',\n         'arkitWillEnterForeground',\n         'arkitInterrupted',\n         'arkitInterruptionEnded',\n         'arkitShowDebug',\n         // elsewhere... 'arkitWindowResize',\n         'onError',\n         'arTrackingChanged',\n         'ios_did_receive_memory_warning',\n         'onComputerVisionData',\n         // above... 'setNativeTime',\n         'userGrantedComputerVisionData',\n         'userGrantedWorldSensingData', // Needed for world sensing.\n        ].forEach(function (eventName) {\n          //if (window[eventName]) {\n          //  console.log('window handler already defined for ', eventName);\n          //} else\n          window[eventName] = function (data) {\n            console.log(eventName + ':', data);\n          };\n        });\n\n        // act like Chrome WebXR by forcibly showing AR button and making it work\n        var vrmodeui = this.el.sceneEl.components['vr-mode-ui'];\n        var newarbutton = vrmodeui.enterAREl.cloneNode(true);\n        vrmodeui.enterAREl.parentNode.replaceChild(newarbutton, vrmodeui.enterAREl);\n        vrmodeui.enterAREl = newarbutton;\n        vrmodeui.enterAREl.classList.remove('a-hidden');\n        var self = this;\n        vrmodeui.enterAREl.onclick = function() {\n          var scene = AFRAME.scenes[0];\n          scene.addState('ar-mode');\n          scene.addState('vr-mode');\n          scene.emit('enter-vr', {target: scene});\n          // this caused Cardboard prompt, so hide it \n          vrmodeui.orientationModalEl.classList.add('a-hidden');\n\n          // not sure these are necessary\n          //scene.addFullScreenStyles();\n          //scene.renderer.setAnimationLoop(scene.render);\n          //scene.resize();\n\n          // Call initAR.\n          window.webkit.messageHandlers.initAR.postMessage(data);\n            \n\n            // Take over the scene camera, if so directed.\n            // But wait a tick, because otherwise injected camera will not be present.\n            if (self.data.takeOverCamera) {\n                setTimeout(function () { self.takeOverCamera(scene.camera); });\n            }\n\n            let sz = new THREE.Vector2();\n            let pixelRatio = scene.renderer.getPixelRatio();\n            scene.renderer.getSize(sz);\n            console.log(\"pixelRatio \", pixelRatio, \" size \", sz);\n/*            scene.renderer.setSize(sz * pixelRatio, sz * pixelRatio);\n            // Modify the scene renderer to allow ARView video passthrough.\n            scene.renderer.setPixelRatio(1);\n            scene.renderer.autoClear = false;\n            scene.renderer.setClearColor('#000', 0);\n            scene.renderer.alpha = true;\n/*\n            // Ugly hack to get around WebXR Viewer resizing issue.\n            setTimeout(function () {\n                var scene = AFRAME.scenes[0];\n                scene.canvas.style.position = \"absolute !important\";\n                scene.canvas.style.width = \"100% !important\";\n                scene.canvas.style.height = \"100% !important\";\n                setTimeout(function () { scene.resize(); });\n            }, 1000);\n*/\n        };\n    },\n\n    checkForARDisplay: function () {\n        // Check if the low-level WebXR Viewer interfaces are there.\n        if (!window.webkit || !window.webkit.messageHandlers) { return; }\n        if (!window.webkit.messageHandlers.watchAR) { return; }\n\n        // Mozilla WebXR Viewer detected.\n        var self = this;\n        self.arDisplay = true;\n\n        // Compose data to use with watchAR.\n        var data = {\n            options: {\n            location: true,\n                camera: true,\n                objects: true,\n                light_intensity: true,\n                worldSensing: this.data.worldSensing\n            },\n            callback: 'arkitCallback1' // this.onWatch as window callback\n        };\n\n        // Add resize handling.\n        window['arkitWindowResize'] = function (data) {\n            console.log('arkitWindowResize' + ':', data);\n\n            setTimeout(function() {\n\n//                AFRAME.scenes[0].resize();\n\n            // something is wacky with orientation change;\n            // I think the polyfill is broken\n            //\n            // crudely resize the canvas according to the data\n            var sc = AFRAME.scenes[0];\n            //sc.canvas.width = data.width * window.devicePixelRatio;\n            //sc.canvas.height = data.height * window.devicePixelRatio;\n            sc.camera.aspect = data.width / data.height;\n            sc.camera.projectionMatrix.copy(self.projectionMatrix); // updateProjectionMatrix();\n\n            sc.renderer.setPixelRatio(1);\n            sc.renderer.setSize(\n                data.width * window.devicePixelRatio,\n                data.height * window.devicePixelRatio,\n                false);\n\n            sc.components['vr-mode-ui'].orientationModalEl.classList.add('a-hidden');\n\n            }, 50);\n        };\n\n        // Start watching AR.\n        window.webkit.messageHandlers.watchAR.postMessage(data);\n    },\n\n    onInit: function (deviceId) {\n        this.checkForARDisplay();\n    },\n\n    onWatch: function (data) {\n        this.frameData = data;\n        this.handleFrame(data);\n    },\n\n    handleFrame: function (data) {\n        // Decompose to get camera pose.\n        this.poseMatrix.fromArray(data.camera_transform);\n        this.poseMatrix.decompose(this.posePosition, this.poseQuaternion, this.poseRotation); // poseRotation is really scale, we redo below\n        this.poseEuler.setFromQuaternion(this.poseQuaternion);\n        this.poseRotation.set(\n            THREE.Math.RAD2DEG * this.poseEuler.x,\n            THREE.Math.RAD2DEG * this.poseEuler.y,\n            THREE.Math.RAD2DEG * this.poseEuler.z);\n\n        this.projectionMatrix.fromArray(data.projection_camera);\n        this.viewMatrix.fromArray(data.camera_view);\n\n        // If we control a camera, and should apply user height, do it.\n        if (this.arCamera && this.data.cameraUserHeight) {\n            this.posePosition.y += this.arCamera.el.components.camera.data.userHeight;\n        }\n\n        // For A-Painter, detect bogus pose and fire poseFound / poseLost.\n        var poseValid = this.posePosition.x || this.posePosition.y || this.posePosition.z || this.poseQuaternion.x || this.poseQuaternion.y || this.poseQuaternion.z;\n        if (poseValid) {\n          if (this.poseLost !== false) {\n            this.poseLost = false;\n            this.el.emit('poseFound');\n          }\n        } else {\n          if (this.poseLost !== true) {\n            this.poseLost = true;\n            this.el.emit('poseLost', false);\n          }\n        }\n\n        // Add planes handling, so we can do synchronous hit test.\n        // From google-ar/WebARonARKit; also see webxr-polyfill/ARKitWrapper.js\n\n        var i;\n        var element;\n\n        // WebXR Viewer returns geometry.vertices as an array of {x: number, y: number, y: number}\n        // https://github.com/mozilla-mobile/webxr-ios/blob/c77b12c235e3960e2cd51538e086a38c83d8ec7c/XRViewer/ARKController/ARKController.m#L845\n        // We transform this to a flatten array of number, like WebARonARCore.\n\n        if(data.newObjects && data.newObjects.length){\n          for (i = 0; i < data.newObjects.length; i++) {\n            element = data.newObjects[i];\n            if(element.plane_center){\n              this.planes_.set(element.uuid, {\n                id: element.uuid,\n                center: element.plane_center,\n                extent: [element.plane_extent.x, element.plane_extent.z],\n                modelMatrix: element.transform,\n                alignment: element.plane_alignment,\n                vertices: element.geometry.vertices\n              });\n            }else{\n              var anchorData = {\n                id: element.uuid,\n                modelMatrix: element.transform\n              };\n              if (element.type === 'image') {\n                anchorData.name = element.uuid;\n              }\n              this.anchors_.set(element.uuid, anchorData);\n            }\n          }\n        }\n\n        if(data.removedObjects && data.removedObjects.length){\n          for (i = 0; i < data.removedObjects.length; i++) {\n            element = data.removedObjects[i];\n            if(this.planes_.get(element)){\n              this.planes_.delete(element);\n            }else{\n              this.anchors_.delete(element);\n            }\n          }\n        }\n\n        if(data.objects && data.objects.length){\n          for (i = 0; i < data.objects.length; i++) {\n            element = data.objects[i];\n            if(element.plane_center){\n              var plane = this.planes_.get(element.uuid);\n              if(!plane){\n                this.planes_.set(element.uuid, {\n                  id: element.uuid,\n                  center: element.plane_center,\n                  extent: [element.plane_extent.x, element.plane_extent.z],\n                  modelMatrix: element.transform,\n                  alignment: element.plane_alignment,\n                  vertices: element.geometry.vertices\n                });\n              } else {\n                plane.center = element.plane_center;\n                plane.extent = [element.plane_extent.x, element.plane_extent.z];\n                plane.modelMatrix = element.transform;\n                plane.alignment = element.plane_alignment;\n                plane.vertices = element.geometry.vertices;\n              }\n            }else{\n              var anchor = this.anchors_.get(element.uuid);\n              if(!anchor){\n                this.anchors_.set(element.uuid, {\n                  id: element.uuid,\n                  modelMatrix: element.transform\n                });\n              }else{\n                anchor.modelMatrix = element.transform;\n              }\n            }\n          }\n        }\n    },\n\n    getPosition: function () {\n        if (!this.arDisplay) { return null; }\n        return this.posePosition;\n    },\n\n    getOrientation: function () {\n        if (!this.arDisplay) { return null; }\n        return this.poseQuaternion;\n    },\n\n    getRotation: function () {\n        if (!this.arDisplay) { return null; }\n        return this.poseRotation;\n    },\n\n    getProjectionMatrix: function () {\n        if (!this.arDisplay) { return null; }\n        return this.projectionMatrix;\n    },\n\n    // Link to new ARKit image marker and anchor support.\n\n    addImage: function (name, url, physicalWidth) {\n        if (!this.arDisplay) { return null; }\n/*\nNSDictionary *imageAnchorInfoDictionary = [message body];\nNSString *createDetectionImageCallback = [[message body] objectForKey:WEB_AR_CALLBACK_OPTION];\n// callback\n\nCGFloat physicalWidth = [referenceImageDictionary[@\"physicalWidth\"] doubleValue];\nNSString* b64String = referenceImageDictionary[@\"buffer\"];\nsize_t width = (size_t) [referenceImageDictionary[@\"imageWidth\"] intValue];\nsize_t height = (size_t) [referenceImageDictionary[@\"imageHeight\"] intValue];\n...\nresult.name = referenceImageDictionary[@\"uid\"];\n*/\n        // NOTE: looks like WebXR Viewer won't load from URL,\n        //       so we need to convert from img element\n        var aCanvas = document.createElement('canvas');\n        var aContext = aCanvas.getContext('2d');\n        var aImg; // Don't use element; chance of changed width/height.\n        if (!aImg) {\n          aImg = document.createElement('img');\n          aImg.crossOrigin = 'anonymous';\n          aImg.src = url;\n          document.body.appendChild(aImg);\n        }\n\n        // The image needs to be loaded...\n        if (!aImg.complete || !aImg.naturalHeight) {\n          console.log('!!! addImage: !aImg.complete || !aImg.naturalHeight, aborting');\n          return;\n        } \n       \n        // The image needs to be have nonzero size...\n        if (!aImg.width || !aImg.height) {\n          console.log('!!! addImage: !aImg.width || !aImg.height, aborting');\n          return;\n        } \n\n        aCanvas.width = aImg.width;\n        aCanvas.height = aImg.height;\n        aContext.drawImage(aImg, 0, 0);\n        var aImageData = aContext.getImageData(0, 0, aImg.width, aImg.height);\n        var b64ImageData = encode(aImageData.data);\n        if (!b64ImageData) {\n          console.log('!!! addImage: !b64ImageData, aborting');\n          return;\n        }\n\n        // NOTE: also, WebXR Viewer doesn't pass back which image/name,\n        //       so we need a per-image/name callback\n        window.callbackForCreateImageAnchorCounter = (window.callbackForCreateImageAnchorCounter || 0) + 1;\n        var callbackName = 'callbackForCreateImageAnchor_' + window.callbackForCreateImageAnchorCounter;\n        var imageName = name;\n        //console.log('creating ', callbackName, ' for ', imageName);\n        window[callbackName] = function (data) {\n          //console.log(callbackName);\n          //console.log(data);\n          //var name = callbackName.substring(29);\n          if (data.created !== undefined) {\n            if (!data.created) {\n              // we failed to create the image, for whatever reason.\n              console.log('addImage: !created; ', data.error);\n              delete window[callbackName];\n            } else {\n              //console.log('addImage: created, activating ', imageName);\n              window.webkit.messageHandlers.activateDetectionImage.postMessage({\n                callback: callbackName,\n                uid: imageName\n              });\n            }\n          } else\n          if (data.activated !== undefined) {\n            if (!data.activated) {\n              // we failed to activate the image, for whatever reason.\n              console.log('addImage: !activated; ', data.error);\n            } else {\n              //console.log('addImage: activated ', imageName);\n            }\n            delete window[callbackName];\n          }\n        };\n\n        window.webkit.messageHandlers.createImageAnchor.postMessage({\n          callback: callbackName,\n          uid: name,\n          buffer: b64ImageData,\n          imageWidth: aImg.width,\n          imageHeight: aImg.height,\n          physicalWidth: physicalWidth // in meters\n        });\n    },\n\n    removeImage: function (name) {\n        if (!this.arDisplay) { return null; }\n/*\nNSDictionary *imageAnchorInfoDictionary = [message body];\nNSString *imageName = imageAnchorInfoDictionary[WEB_AR_DETECTION_IMAGE_NAME_OPTION];\n// detectionImageName\nNSString *deactivateDetectionImageCallback = [[message body] objectForKey:WEB_AR_CALLBACK_OPTION];\n// callback\n*/\n        window.callbackForRemoveImageAnchorCounter = (window.callbackForRemoveImageAnchorCounter || 0) + 1;\n        var callbackName = 'callbackForRemoveImageAnchor_' + window.callbackForRemoveImageAnchorCounter;\n        var imageName = name;\n        //console.log('creating ', callbackName, ' for ', imageName);\n        window[callbackName] = function (data) {\n          //console.log(callbackName);\n          //console.log(data);\n\n          if (data.deactivated !== undefined) {\n            if (!data.deactivated) {\n              console.log('!!! ' + callbackName + ': !deactivated', data.error);\n              delete window[callbackName];\n            } else {\n              //console.log(callbackName + ': deactivated, destroying', imageName);\n            }\n            window.webkit.messageHandlers.destroyDetectionImage.postMessage({\n              callback: callbackName,\n              uid: imageName\n            });\n          }\n          if (data.destroyed !== undefined) {\n            if (!data.destroyed) {\n              console.log('!!! ' + callbackName + ': !destroyed, ', data.error);\n            } else {\n              //console.log(callbackName + ': destroyed', imageName);\n            }\n            delete window[callbackName];\n          }\n        };\n\n        window.webkit.messageHandlers.deactivateDetectionImage.postMessage({\n          callback: callbackName,\n          uid: imageName\n        });\n    },\n\n    getAnchors: function () {\n        return Array.from(this.anchors_.values());\n    },\n\n    // Use planes to do synchronous hit test.\n    // From google-ar/WebARonARKit; also see webxr-polyfill/ARKitWrapper.js\n\n    getPlanes: function () {\n        return Array.from(this.planes_.values());\n    },\n\n    hitTestNoAnchor: (function () {\n        // Temporary variables, only within closure scope.\n\n        /**\n         * The result of a raycast into the AR world encoded as a transform matrix.\n         * This structure has a single property - modelMatrix - which encodes the\n         * translation of the intersection of the hit in the form of a 4x4 matrix.\n         * @constructor\n         */\n        function VRHit() {\n            this.modelMatrix = new Float32Array(16);\n            return this;\n        };\n\n                       /**\n            * Cached vec3, mat4, and quat structures needed for the hit testing to\n            * avoid generating garbage.\n            * @type {Object}\n            */\n            var hitVars = {\n             rayStart: new THREE.Vector3(), //vec3.create(),\n             rayEnd: new THREE.Vector3(), //vec3.create(),\n             cameraPosition: new THREE.Vector3(), //vec3.create(),\n             cameraQuaternion: new THREE.Quaternion(), //quat.create(),\t\n             //modelViewMatrix: new THREE.Matrix4(), //mat4.create(),\n             //projectionMatrix: new THREE.Matrix4(), //mat4.create(),\n             projViewMatrix: new THREE.Matrix4(), //mat4.create(),\n             worldRayStart: new THREE.Vector3(), //vec3.create(),\n             worldRayEnd: new THREE.Vector3(), //vec3.create(),\n             worldRayDir: new THREE.Vector3(), //vec3.create(),\n             planeMatrix: new THREE.Matrix4(), //mat4.create(),\n             planeMatrixInverse: new THREE.Matrix4(), //mat4.create(),\n             planeExtent: new THREE.Vector3(), //vec3.create(),\n             planePosition: new THREE.Vector3(), //vec3.create(),\n             planeCenter: new THREE.Vector3(), //vec3.create(),\n             planeNormal: new THREE.Vector3(), //vec3.create(),\n             planeIntersection: new THREE.Vector3(), //vec3.create(),\n             planeIntersectionLocal: new THREE.Vector3(), //vec3.create(),\n             planeHit: new THREE.Matrix4(), //mat4.create()\n             planeQuaternion: new THREE.Quaternion()  // quat.create()\n         };\n \n         /**\n            * Tests whether the given ray intersects the given plane.\n            *\n            * @param {!vec3} planeNormal The normal of the plane.\n            * @param {!vec3} planePosition Any point on the plane.\n            * @param {!vec3} rayOrigin The origin of the ray.\n            * @param {!vec3} rayDirection The direction of the ray (normalized).\n            * @return {number} The t-value of the intersection (-1 for none).\n            */\n         var rayIntersectsPlane = (function() {\n             var rayToPlane = new THREE.Vector3();\n             return function(planeNormal, planePosition, rayOrigin, rayDirection) {\n                 // assuming vectors are all normalized\n                 var denom = planeNormal.dot(rayDirection);\n                 rayToPlane.subVectors(planePosition, rayOrigin);\n                 return rayToPlane.dot(planeNormal) / denom;\n             };\n         })();\n \n         /**\n            * Sorts based on the distance from the VRHits to the camera.\n            *\n            * @param {!VRHit} a The first hit to compare.\n            * @param {!VRHit} b The second hit item to compare.\n            * @returns {number} -1 if a is closer than b, otherwise 1.\n            */\n         var sortFunction = function(a, b) {\n             // Get the matrix of hit a.\n             hitVars.planeMatrix.fromArray(a.modelMatrix);\n             // Get the translation component of a's matrix.\n             hitVars.planeIntersection.setFromMatrixPosition(hitVars.planeMatrix);\n             // Get the distance from the intersection point to the camera.\n             var distA = hitVars.planeIntersection.distanceTo(hitVars.cameraPosition);\n \n             // Get the matrix of hit b.\n             hitVars.planeMatrix.fromArray(b.modelMatrix);\n             // Get the translation component of b's matrix.\n             hitVars.planeIntersection.setFromMatrixPosition(hitVars.planeMatrix);\n             // Get the distance from the intersection point to the camera.\n             var distB = hitVars.planeIntersection.distanceTo(hitVars.cameraPosition);\n \n             // Return comparison of distance from camera to a and b.\n             return distA < distB ? -1 : 1;\n         };\n \n         return function(x, y) {\n             // Coordinates must be in normalized screen space.\n             if (x < 0 || x > 1 || y < 0 || y > 1) {\n                 throw new Error(\n                         \"hitTest - x and y values must be normalized [0,1]!\")\n                 ;\n             }\n \n             var hits = [];\n             // If there are no anchors detected, there will be no hits.\n             var planes = this.getPlanes();\n             if (!planes || planes.length === 0) {\n                 return hits;\n             }\n\n             // Create a ray in screen space for the hit test ([-1, 1] with y flip).\n             hitVars.rayStart.set(2 * x - 1, 2 * (1 - y) - 1, 0);\n             hitVars.rayEnd.set(2 * x - 1, 2 * (1 - y) - 1, 1);\n\n             // Set the projection matrix.\n             //hitVars.projectionMatrix.fromArray(this.projectionMatrix);\n \n             // Set the model view matrix.\n             //hitVars.modelViewMatrix.fromArray(this.viewMatrix);\n \n             // Combine the projection and model view matrices.\n             hitVars.planeMatrix.multiplyMatrices(\n                 this.projectionMatrix, //hitVars.projectionMatrix,\n                 this.viewMatrix //hitVars.modelViewMatrix\n             );\n             // Invert the combined matrix because we need to go from screen -> world.\n             hitVars.projViewMatrix.getInverse(hitVars.planeMatrix);\n \n             // Transform the screen-space ray start and end to world-space.\n             hitVars.worldRayStart.copy(hitVars.rayStart)\n                 .applyMatrix4(hitVars.projViewMatrix);\n             hitVars.worldRayEnd.copy(hitVars.rayEnd)\n                 .applyMatrix4(hitVars.projViewMatrix);\n \n             // Subtract start from end to get the ray direction and then normalize.\n             hitVars.worldRayDir.subVectors(\n                 hitVars.worldRayEnd,\n                 hitVars.worldRayStart\n             ).normalize();\n\n             // Go through all the anchors and test for intersections with the ray.\n             for (var i = 0; i < planes.length; i++) {\n                 var plane = planes[i];\n                 // Get the anchor transform.\n                 hitVars.planeMatrix.fromArray(plane.modelMatrix);\n \n                 // Get the position of the anchor in world-space.\n                 hitVars.planeCenter.set(plane.center.x, plane.center.y, plane.center.z);\n                 hitVars.planePosition.copy(hitVars.planeCenter)\n                     .applyMatrix4(hitVars.planeMatrix)\n\n                 hitVars.planeAlignment = plane.alignment\n \n                 // Get the plane normal.\n                 if (hitVars.planeAlignment === 0) {\n                     hitVars.planeNormal.set(0, 1, 0);\n                 } else {\n                     hitVars.planeNormal.set(hitVars.planeMatrix[4], hitVars.planeMatrix[5], hitVars.planeMatrix[6]);\n                 }\n \n                 // Check if the ray intersects the plane.\n                 var t = rayIntersectsPlane(\n                     hitVars.planeNormal,\n                     hitVars.planePosition,\n                     hitVars.worldRayStart,\n                     hitVars.worldRayDir\n                 );\n\n                 // if t < 0, there is no intersection.\n                 if (t < 0) {\n                     continue;\n                 }\n \n                 // Calculate the actual intersection point.\n                 hitVars.planeIntersectionLocal.copy(hitVars.worldRayDir).multiplyScalar(t);\n                 hitVars.planeIntersection.addVectors(\n                     hitVars.worldRayStart,\n                     hitVars.planeIntersectionLocal\n                 );\n                 // Get the plane extents (extents are in plane local space).\n                 hitVars.planeExtent.set(plane.extent[0], 0, plane.extent[1]);\n                 /*\n                     ///////////////////////////////////////////////\n                     // Test by converting extents to world-space.\n                     // TODO: get this working to avoid matrix inversion in method below.\n \n                     // Get the rotation component of the anchor transform.\n                     mat4.getRotation(hitVars.planeQuaternion, hitVars.planeMatrix);\n \n                     // Convert the extent into world space.\n                     vec3.transformQuat(\n                     hitVars.planeExtent, hitVars.planeExtent, hitVars.planeQuaternion);\n \n                     // Check if intersection is outside of the extent of the anchor.\n                     if (Math.abs(hitVars.planeIntersection[0] - hitVars.planePosition[0]) > hitVars.planeExtent[0] / 2) {\n                     continue;\n                     }\n                     if (Math.abs(hitVars.planeIntersection[2] - hitVars.planePosition[2]) > hitVars.planeExtent[2] / 2) {\n                     continue;\n                     }\n                     ////////////////////////////////////////////////\n                     */\n \n                 ////////////////////////////////////////////////\n                 // Test by converting intersection into plane-space.\n                 hitVars.planeMatrixInverse.getInverse(hitVars.planeMatrix);\n                 hitVars.planeIntersectionLocal.copy(hitVars.planeIntersection)\n                     .applyMatrix4(hitVars.planeMatrixInverse);\n \n                 // Check if intersection is outside of the extent of the anchor.\n                 // Tolerance is added to match the behavior of the native hitTest call.\n                 var tolerance = 0.0075;\n                 if (\n                     Math.abs(hitVars.planeIntersectionLocal.x) >\n                     hitVars.planeExtent.x / 2 + tolerance\n                 ) {\n                     continue;\n                 }\n                 if (\n                     Math.abs(hitVars.planeIntersectionLocal.z) >\n                     hitVars.planeExtent.z / 2 + tolerance\n                 ) {\n                     continue;\n                 }\n \n                 ////////////////////////////////////////////////\n \n                 // The intersection is valid - create a matrix from hit position.\n                 hitVars.planeQuaternion.setFromRotationMatrix(hitVars.planeMatrix);\n                 hitVars.planeHit.makeRotationFromQuaternion(hitVars.planeQuaternion).setPosition(hitVars.planeIntersection);\n                var hit = new VRHit();\n                 for (var j = 0; j < 16; j++) {\n                     hit.modelMatrix[j] = hitVars.planeHit.elements[j];\n                 }\n                 hit.i = i;\n                 hits.push(hit);\n             }\n \n\n             // Sort the hits by distance.\n             hits.sort(sortFunction);\n             return hits;\n         };\n    })(),\n\n    hitAR: (function () {\n        // Temporary variables, only within closure scope.\n        var transform = new THREE.Matrix4();\n        var hitpoint = new THREE.Vector3();\n        var hitquat = new THREE.Quaternion();\n        var hitscale = new THREE.Vector3();\n        var worldpos = new THREE.Vector3();\n\n        // The desired function, which this returns.\n        return function (x, y, el, raycasterEl) {\n            if (!this.arDisplay) { return []; }\n\n            var hit = this.hitTestNoAnchor(x, y);\n\n            // Process AR hits.\n            var hitsToReturn = [];\n            for (var i = 0; hit && i < hit.length; i++) {\n                transform.fromArray(hit[i].modelMatrix);\n                transform.decompose(hitpoint, hitquat, hitscale);\n                raycasterEl.object3D.getWorldPosition(worldpos);\n\n                hitsToReturn.push({\n                    distance: hitpoint.distanceTo(worldpos),\n                    point: hitpoint.clone(), // Vector3\n                    object: (el && el.object3D) || this.el.sceneEl.object3D\n/*\n                    // We don't have any of these properties...\n                    face: undefined, // Face3\n                    faceIndex: undefined,\n                    index: undefined,\n                    uv: undefined // Vector2\n*/\n                });\n            }\n            return hitsToReturn;\n        }   \n    })()\n});\n","/* global AFRAME, THREE, VRFrameData */\n\nAFRAME.registerComponent('webxr-ar', {\n    schema: {\n        takeOverCamera: {default: true},\n        cameraUserHeight: {default: false},\n        worldSensing: {default: false} // currently unused\n    },\n\n    init: function () {\n        this.posePosition = new THREE.Vector3();\n        this.poseQuaternion = new THREE.Quaternion();\n        this.poseEuler = new THREE.Euler(0, 0, 0, 'YXZ');\n        this.poseRotation = new THREE.Vector3();\n        this.projectionMatrix = new THREE.Matrix4();\n\n        this.onceSceneLoaded = this.onceSceneLoaded.bind(this);\n        if (this.el.sceneEl.hasLoaded) {\n            setTimeout(this.onceSceneLoaded);\n        } else {\n            this.el.sceneEl.addEventListener('loaded', this.onceSceneLoaded);\n        }\n\n        // Add planes handling, so we can do synchronous hit test.\n\n        this.rawPlanes_ = null;\n        this.planes_ = new Map();\n        this.anchors_ = new Map();\n    },\n\n    convertPolygonToVertices: function(polygon) {\n        return newVertices;\n    },\n\n    convertedPlane: function(rawPlane, pose) {\n        var mins = [0, 0];\n        var maxs = [0, 0];\n        var verticesLength = rawPlane.polygon.length;\n        var newVertices = new Float32Array(verticesLength * 3);\n        var i = 0;\n        var j = 0;\n        var vertex;\n        for (i = 0; i < verticesLength; i++) {\n            vertex = rawPlane.polygon[i];\n            newVertices[j] = vertex.x;\n            newVertices[j + 1] = vertex.y;\n            newVertices[j + 2] = vertex.z;\n            j += 3;\n            if (i == 0) {\n                mins[0] = maxs[0] = vertex.x;\n                mins[1] = maxs[1] = vertex.z;\n            } else {\n                if (mins[0] > vertex.x) { mins[0] = vertex.x; }\n                if (maxs[0] < vertex.x) { maxs[0] = vertex.x; }\n                if (mins[1] > vertex.z) { mins[1] = vertex.z; }\n                if (maxs[1] < vertex.z) { maxs[1] = vertex.z; }\n            }\n        }\n        var position = pose.transform.position;\n        rawPlane.position.set(position.x, position.y, position.z);\n        var converted = {\n            id: rawPlane.id,\n            center: rawPlane.position,\n            extent: [maxs[0] - mins[0], maxs[1] - mins[1]],\n            modelMatrix: pose.transform.matrix,\n            alignment: rawPlane.orientation != 'Horizontal' ? 1 : 0,\n            vertices: newVertices\n        };\n        return converted;\n    },\n\n    rawPlaneRemoved: function(rawPlane) {\n        // remove the converted plane\n        this.planes_.delete(rawPlane.id);\n    },\n\n    rawPlaneUpdated: function(rawPlane, pose) {\n        // convert the updated plane\n        this.planes_.set(rawPlane.id, this.convertedPlane(rawPlane, pose));\n    },\n\n    rawPlaneNotUpdated: function(rawPlane, pose) {\n        // FIXME: check is broken so update anyway\n        this.rawPlaneUpdated(rawPlane, pose);\n        // do nothing\n    },\n\n    rawPlaneCreated: function(rawPlane, pose) {\n        // assign and attach an id... for now, use Math.random()\n        rawPlane.id = Math.random().toString().substring(2);\n        rawPlane.position = new THREE.Vector3();\n        // convert the plane\n        this.planes_[rawPlane.id] = this.convertedPlane(rawPlane, pose);\n    },\n\n    tick: function (t, dt) {\n        let frame = this.el.sceneEl.frame;\n        if (!this.arDisplay\n         || !frame\n         || !frame.worldInformation) { return; }\n\n        // use the planes information\n        let world = frame.worldInformation;\n\n        // check for removed planes\n        this.rawPlanes_ && this.rawPlanes_.forEach(plane => {\n            if(!world.detectedPlanes || !world.detectedPlanes.has(plane)) {\n                // Handle removed plane - `plane` was present in previous frame but is no longer tracked.\n                this.rawPlaneRemoved(plane);\n            }\n        });\n\n        // check for changed planes\n        let timestamp = this.el.sceneEl.time;\n        world.detectedPlanes && world.detectedPlanes.forEach(plane => {\n            let planePose = frame.getPose(plane.planeSpace, this.refSpace);\n            if (this.rawPlanes_.has(plane)) {\n                if(plane.lastChangedTime == timestamp) {\n                    // Handle previously seen plane that was updated in current frame.\n                    this.rawPlaneUpdated(plane, planePose);\n                } else {\n                    // Handle previously seen plane that was not updated in current frame.\n                    // Depending on the application, this could be a no-op.\n                    this.rawPlaneNotUpdated(plane, planePose);\n                }\n            } else {\n                // Handle new plane.\n                this.rawPlaneCreated(plane, planePose);\n            }\n        });\n \n        this.rawPlanes_ = world.detectedPlanes;\n    },\n\n    takeOverCamera: function (camera) {\n        this.arCamera = camera;\n        camera.isARPerspectiveCamera = true; // HACK - is this necessary?\n        camera.vrDisplay = this.arDisplay; // HACK - is this necessary?\n        camera.el.setAttribute('ar-camera', 'enabled', true);\n    },\n\n    onceSceneLoaded: function () {\n        var self = this;\n        window.addEventListener('ardisplayconnect', function () {\n            if (!self.arDisplay) { self.checkForARDisplay(); }\n        });\n\n        // Check now for AR display.\n        this.checkForARDisplay();\n    },\n\n    checkForARDisplay: function () {\n        // check to see if webxr ar mode is supported\n        if (!navigator.xr || !navigator.xr.isSessionSupported) { return; }\n\n            var self = this;\n        self.arDisplay = {type: 'webxr-ar'};\n\n        navigator.xr.isSessionSupported('immersive-ar').then(function(supported) {\n          if (supported) {\n            let ourRequiredFeatures = ['local-floor'];\n            let ourOptionalFeatures = [];\n            (self.data.worldSensing ? ourRequiredFeatures : ourOptionalFeatures).push('hit-test');\n            let existingFeatures = self.el.sceneEl.getAttribute('webxr');\n            if (!existingFeatures) {\n                // here, we assume we can set as map and not String (?) \n                self.el.sceneEl.setAttribute('webxr', { \n                    requiredFeatures: ourRequiredFeatures.join(','), \n                    optionalFeatures: ourOptionalFeatures.join(',') \n                });\n            } else {\n                // here, we assume we get and set as map and not String (?)\n                // remove existing optional features from our optional\n                existingFeatures.optionalFeatures.forEach(function (feature) {\n                    ourOptionalFeatures = ourOptionalFeatures.filter(function(value, index, arr){ return value != feature;});\n                });\n                // remove existing required features from our required\n                existingFeatures.requiredFeatures.forEach(function (feature) {\n                    ourRequiredFeatures = ourRequiredFeatures.filter(function(value, index, arr){ return value != feature;});\n                });\n                // remove our required features from existing optional\n                ourRequiredFeatures.forEach(function (feature) {\n                    existingFeatures.optionalFeatures = existingFeatures.optionalFeatures.filter(function(value, index, arr){ return value != feature;});\n                });\n                // add our required and optional features to the existing\n                existingFeatures.requiredFeatures = existingFeatures.requiredFeatures.concat(ourRequiredFeatures);\n                existingFeatures.optionalFeatures = existingFeatures.optionalFeatures.concat(ourOptionalFeatures);\n\n                self.el.sceneEl.setAttribute('webxr', existingFeatures);\n            }\n\n            self.el.sceneEl.setAttribute('vr-mode-ui', \"enabled\", \"true\");\n            // auto-entering AR doesn't work.\n\n            self.xrHitTestSource = null;\n            self.viewerSpace = null;\n            self.refSpace = null;\n\n            self.el.sceneEl.renderer.xr.addEventListener('sessionend', (ev) => {\n                self.viewerSpace = null;\n                self.refSpace = null;\n                self.xrHitTestSource = null;\n            });\n            self.el.sceneEl.renderer.xr.addEventListener('sessionstart', (ev) => {\n                let session = self.el.sceneEl.renderer.xr.getSession();\n                let el = self.el.sceneEl.canvas;\n\n                session.addEventListener('selectstart', function (e) {\n                    // dispatch touchstart\n                    var pageX = e.inputSource.gamepad.axes[0];\n                    var pageY = e.inputSource.gamepad.axes[1];\n                    setTimeout(() => {\n                        var event = new TouchEvent('touchstart', {\n                            view: window,\n                            bubbles: true,\n                            cancelable: true\n                        });\n                        event.targetTouches = [{ pageX: pageX, pageY: pageY }];\n                        el.dispatchEvent(event);\n                    });\n                });\n\n                session.addEventListener('selectend', function (e) {\n                    // dispatch touchend\n                    var pageX = e.inputSource.gamepad.axes[0];\n                    var pageY = e.inputSource.gamepad.axes[1];\n                    setTimeout(() => {\n                        var event = new TouchEvent('touchend', {\n                            view: window,\n                            bubbles: true,\n                            cancelable: true\n                        });\n                        event.targetTouches = [{ pageX: pageX, pageY: pageY }];\n                        el.dispatchEvent(event);\n                    });\n                });\n\n                session.addEventListener('select', function (e) {\n                    // dispatch click\n                    var pageX = e.inputSource.gamepad.axes[0];\n                    var pageY = e.inputSource.gamepad.axes[1];\n                    setTimeout(() => {\n                        var event = new MouseEvent('click', { \n                            clientX: pageX, \n                            clientY: pageY, \n                            bubbles: true,\n                            cancelable: true\n                        });\n                        el.dispatchEvent(event);\n                    });\n                });\n\n                session.requestReferenceSpace('viewer').then((space) => {\n                    self.viewerSpace = space;\n                    if (self.data.worldSensing) {\n                        session.requestHitTestSource({space: self.viewerSpace})\n                        .then((hitTestSource) => {\n                            self.xrHitTestSource = hitTestSource;\n                        })\n                    }\n                });\n\n                session.requestReferenceSpace('local-floor').then((space) => {\n                    self.refSpace = space;\n                });\n\n                // Ask for planes, if we should.\n                if (self.data.worldSensing) {\n                    session.updateWorldTrackingState({planeDetectionState : {enabled : true}});\n                }\n            });\n          }\n        });\n    },\n\n    getPosition: function () {\n        if (!this.arDisplay || !this.arDisplay.getFrameData) { return null; }\n        return this.posePosition;\n    },\n\n    getOrientation: function () {\n        if (!this.arDisplay || !this.arDisplay.getFrameData) { return null; }\n        return this.poseQuaternion;\n    },\n\n    getRotation: function () {\n        if (!this.arDisplay || !this.arDisplay.getFrameData) { return null; }\n        return this.poseRotation;\n    },\n\n    getProjectionMatrix: function () {\n        if (!this.arDisplay || !this.arDisplay.getFrameData) { return null; }\n        return this.projectionMatrix;\n    },\n\n    hitAR: (function () {          \n        // Temporary variables, only within closure scope.\n        var transform = new THREE.Matrix4();\n        var hitpoint = new THREE.Vector3();\n        var hitquat = new THREE.Quaternion();\n        var hitscale = new THREE.Vector3();\n        var worldpos = new THREE.Vector3();\n          \n        // The desired function, which this returns.\n        return function (x, y, el, raycasterEl) {\n            if (!this.arDisplay) { return []; }\n            var hitsToReturn = [];\n\n            if (this.el.sceneEl.is('ar-mode')) {\n              if (!this.viewerSpace) return;\n\n              let frame = this.el.sceneEl.frame;\n              let xrViewerPose = frame.getViewerPose(this.refSpace);\n\n              if (this.xrHitTestSource && xrViewerPose) {\n                let hitTestResults = frame.getHitTestResults(this.xrHitTestSource);\n\n                    // Process AR hits.\n                    var hitsToReturn = [];\n                    for (var i = 0; hitTestResults && i < hitTestResults.length; i++) {\n                    let pose = hitTestResults[i].getPose(this.refSpace);\n                        transform.fromArray(pose.transform.matrix);\n                        hitpoint.setFromMatrixPosition(transform); //transform.decompose(hitpoint, hitquat, hitscale);\n                        raycasterEl.object3D.getWorldPosition(worldpos);\n\n                        hitsToReturn.push({\n                            distance: hitpoint.distanceTo(worldpos),\n                            point: hitpoint.clone(), // Vector3\n                            object: (el && el.object3D) || this.el.sceneEl.object3D\n/*\n                            // We don't have any of these properties...\n                            face: undefined, // Face3\n                            faceIndex: undefined,\n                            index: undefined,\n                            uv: undefined // Vector2\n*/\n                        });\n                    }\n                }\n            }\n\n            return hitsToReturn;\n        }\n    })(),\n\n    // Link to image marker and anchor support.\n\n    addImage: function (name, url, physicalWidth) {\n        if (!this.arDisplay) { return null; }\n\n        return null;\n    },\n\n    removeImage: function (name) {\n        if (!this.arDisplay) { return null; }\n\n        return null;\n    },\n\n    getAnchors: function () {\n        return Array.from(this.anchors_.values());\n    },\n\n    // Use planes to do synchronous hit test.\n\n    getPlanes: function () {\n        return Array.from(this.planes_.values());\n    }\n});\n"],"sourceRoot":""}